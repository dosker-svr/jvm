## Код для исспледования:
```java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```


## Пояснение:
 - [1] public class JvmComprehension { /* 1 - загружаем класс, проверяем его валидность, загрузка примитивов, связывание ссылок.
                                 в Metaspace заводится ячейка с данными о классе JvmComprehension*/

 - [2] public static void main(String[] args) { /* 2 - начинается исполнение метоа
                                                    и соответсвенно в Stack Memory создаётся область frame для метода main*/
 - [3] int i = 1;// 3 - во frame(под main), выделяется место для объектов / примитивов. и в этот frame добавляем примитив int i = 1
        
 - [4] Object o = new Object(); // 4 - загрузится класс Object. в heap создаётся объект Object, а в Stack добавляется ссылка-переменная на этот объект(в куче)
 - [5] Integer ii = 2; // 5 - загрузится класс Integer. точно также в heap создаётся объект Integer, и в Stack добавляется ссылка-переменная ii
 - [6] printAll(o, i, ii);             // 6 - вызывается метод текущего класса
 
 - [10] System.out.println("finished"); // 10 - проделается такая же непростая процедура как для пункта 9
    }

 - [7] private static void printAll(Object o, int i, Integer ii) { /* 7 - соответсвенно в Stack Memory создается новый frame 'printAll'
        т.к. в метод передали ссылки на Object o, i и ii, то ссылки на объекты копируются в этот новый фрейм*/
        
 - [8] Integer uselessVar = 700; // 8 - в куче создаётся объект, а во frame(под printAll) добавляется ссылка-переменная 'uselessVar'
        
 - [9] System.out.println(o.toString() + i + ii);  /* 9 - загрузится класс System. в Stack создасться новый frame(под out)
                                                 загрузится класс PrintStream. далее в Stack создастся ещё один frame(под println).
                                                 загрузится класс String. в куче создается объект new String() (в аргументах println вызвали его создание).
                                                 наверное в Stack создастся новый frame(под конструктор String). в нем будут копии ссылок (o, i, ii) на объекты из heap*/
    }
}
